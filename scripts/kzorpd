#!/usr/bin/env python2.7

"""
KZorp Daemon

This is a stand alone daemon with the following responsibilities:

 - initial zone download to KZorp
 - continuous update of hostanme par of zones in KZorp

"""

from __future__ import absolute_import
from __future__ import division
from __future__ import generators
from __future__ import unicode_literals
from __future__ import print_function
from __future__ import nested_scopes
from __future__ import with_statement

import daemon
from daemon.pidlockfile import PIDLockFile
import itertools
import socket

import os
import pwd

import time
import prctl
import traceback
import radix

import Zorp.Common as Common
import Zorp.ResolverCache as ResolverCache

import kzorp.kzorp_netlink as kznl

from Zorp.Subnet import Subnet
from Zorp.Zone import Zone
from Zorp.InstancesConf import InstancesConf
from zorpctl.ZorpctlConf import ZorpctlConfig


class ZoneDownload(object):
    def __init__(self):
        self.kzorp_handle = kznl.Handle()

    def __enter__(self):
        self.__acquire_caps()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.__drop_caps()

    def __acquire_caps(self):
        """ aquire the CAP_NET_ADMIN capability """

        try:
            prctl.set_caps((prctl.CAP_NET_ADMIN, prctl.CAP_EFFECTIVE, True))
        except OSError, e:
            Common.log(None, Common.CORE_ERROR, 1, "Unable to acquire NET_ADMIN capability; error='%s'" % (e))
            raise e

    def __drop_caps(self):
        """ drop the CAP_NET_ADMIN capability """

        try:
            prctl.set_caps((prctl.CAP_NET_ADMIN, prctl.CAP_EFFECTIVE, False))
        except OSError, e:
            Common.log(None, Common.CORE_ERROR, 1, "Unable to drop NET_ADMIN capability; error='%s'" % (e))
            raise e

    def __send_messages(self, messages):
        try:
            kznl.startTransaction(self.kzorp_handle, kznl.KZ_INSTANCE_GLOBAL)

            for message in messages:
                self.kzorp_handle.exchange(message)

            kznl.commitTransaction(self.kzorp_handle)
        except kznl.NetlinkException as e:
            Common.log(None, Common.CORE_ERROR, 6,
                       "Error occured while downloading zones to kernel; error='%s'" % (e.detail))
            raise e

    def initial(self, messages):
        self.__send_messages([kznl.KZorpFlushZonesMessage(), ] + messages)

    def update(self, messages):
        self.__send_messages(messages)


class DynamicZoneHandler(object):
    def __init__(self, zones, dnscache):
        self.zones = zones
        self.dnscache = dnscache

    def setup_dns_cache(self):
        """
        Fills up the DNS cache with host found in zones.py
        """

        for zone in self.zones:
            for hostname in zone.hostnames:
                try:
                    self.dnscache.addHost(hostname)
                    ttl = self.dnscache.lookupTTL(hostname)
                    dnsaddresses = self.dnscache.lookupHostname(hostname)
                    Common.log(None, Common.CORE_DEBUG, 6,
                               "Hostname initially added to the cache; name='%s', ttl='%d', addresses='%s', zone='%s'" %
                               (hostname, ttl, dnsaddresses, zone.name))
                except KeyError:
                    Common.log(None, Common.CORE_ERROR, 2,
                               "Hostname cannot be resolved; name='%s', zone='%s'" %
                               (hostname, zone.name))

    def _create_add_zone_messages_from_zone(self, zone, num_of_hostname_subnets = 0):
        subnet_num = len(zone.subnets) + num_of_hostname_subnets
        pname = zone.admin_parent.name if zone.admin_parent else None
        return kznl.KZorpAddZoneMessage(zone.name, pname, subnet_num = subnet_num)

    def _create_add_zone_subnet_messages_from_zone(self, zone):
        add_zone_subnet_messages = []
        for subnet in zone.subnets:
            add_zone_subnet_message = kznl.KZorpAddZoneSubnetMessage(zone.name,
                                                                     subnet.get_family(),
                                                                     subnet.addr_packed(),
                                                                     subnet.netmask_packed())
            add_zone_subnet_messages.append(add_zone_subnet_message)
        return add_zone_subnet_messages

    def create_zone_static_address_initialization_messages(self):
        add_zone_messages = []
        add_zone_subnet_messages = []
        for zone in sorted(self.zones, cmp=lambda z1, z2: cmp(z1.getDepth(), z2.getDepth())):
            add_zone_messages += [self._create_add_zone_messages_from_zone(zone), ]
            add_zone_subnet_messages += self._create_add_zone_subnet_messages_from_zone(zone)
        return add_zone_messages + add_zone_subnet_messages

    def _create_hostname_address_to_zone_map(self, updatable_zone):
        hostname_address_to_zone_map = {}
        for (zone_name, zone) in Zone.zones.iteritems():
            if zone_name == updatable_zone.name:
                continue

            for hostname in zone.hostnames:
                try:
                    ipv4_addresses, ipv6_addresses = self.dnscache.lookupHostname(hostname)
                except KeyError:
                    ipv4_addresses, ipv6_addresses = (set(), set())
                for address in ipv4_addresses | ipv6_addresses:
                    hostname_address_to_zone_map[address] = zone
        return hostname_address_to_zone_map

    @staticmethod
    def _create_conflicting_zone_to_address_map(add_zone_subnet_messages_for_dynamic_addresses,
                                                hostname_address_to_zone_map, updatable_zone):
        conflicting_zone_addresses_map = {}
        for msg in add_zone_subnet_messages_for_dynamic_addresses:
            address = socket.inet_ntop(msg.family, msg.address)
            zone = hostname_address_to_zone_map.get(address, None)
            if zone is not None and zone.name != updatable_zone.name:
                conflicting_zone_addresses_map[zone] = conflicting_zone_addresses_map.get(zone, []) + [address, ]
        return conflicting_zone_addresses_map

    def create_zone_update_messages(self, expired_hostname):
        updatable_zone = Zone.lookupByHostname(expired_hostname)

        if updatable_zone is None:
            return []

        delete_zone_messages = [kznl.KZorpDeleteZoneMessage(updatable_zone.name), ]
        add_zone_subnet_messages_for_static_addresses = self._create_add_zone_subnet_messages_from_zone(updatable_zone)
        add_zone_subnet_messages_for_dynamic_addresses = self._create_add_zone_subnet_messages_of_hostnames(
            updatable_zone)

        hostname_address_to_zone_map = self._create_hostname_address_to_zone_map(updatable_zone)
        conflicting_zone_addresses_map = self._create_conflicting_zone_to_address_map(
            add_zone_subnet_messages_for_dynamic_addresses, hostname_address_to_zone_map, updatable_zone)

        add_zone_subnet_messages_for_dynamic_addresses = filter(
            lambda msg: socket.inet_ntop(msg.family, msg.address) not in conflicting_zone_addresses_map,
            add_zone_subnet_messages_for_dynamic_addresses)
        for (conflicting_zone, conflicting_addresses) in conflicting_zone_addresses_map.iteritems():
            delete_zone_messages += [kznl.KZorpDeleteZoneMessage(conflicting_zone.name), ]
            add_zone_subnet_messages_for_static_addresses += self._create_add_zone_subnet_messages_from_zone(
                conflicting_zone)
            add_zone_subnet_messages = self._create_add_zone_subnet_messages_of_hostnames(conflicting_zone)
            add_zone_subnet_messages_for_dynamic_addresses = \
                filter(lambda msg: socket.inet_ntop(msg.family, msg.address) not in conflicting_addresses,
                       add_zone_subnet_messages_for_dynamic_addresses) + \
                filter(lambda msg: socket.inet_ntop(msg.family, msg.address) not in conflicting_addresses,
                       add_zone_subnet_messages)

        zone_names = set([ msg.name for msg in delete_zone_messages ])
        add_zone_messages = []
        for zone_name in zone_names:
            subnet_num = len(filter(lambda msg: msg.zone_name == zone_name,
                                    add_zone_subnet_messages_for_static_addresses + \
                                    add_zone_subnet_messages_for_dynamic_addresses))
            zone = Zone.lookupByName(zone_name)
            parent_name = zone.admin_parent.name if zone.admin_parent is not None else None
            add_zone_messages += [ kznl.KZorpAddZoneMessage(zone.name, parent_name, subnet_num), ]

        return delete_zone_messages + add_zone_messages + \
            add_zone_subnet_messages_for_static_addresses + \
            add_zone_subnet_messages_for_dynamic_addresses

    def update_zone(self, hostname):
        pass

    @staticmethod
    def __create_add_zone_subnet_messages(zone, ipv4_addresses, ipv6_addresses):
        add_zone_subnet_messages = []

        for address in ipv4_addresses:
            add_zone_subnet_message = kznl.KZorpAddZoneSubnetMessage(zone.name, socket.AF_INET,
                                                                     socket.inet_pton(socket.AF_INET, address))
            add_zone_subnet_messages.append(add_zone_subnet_message)
        for address in ipv6_addresses:
            add_zone_subnet_message = kznl.KZorpAddZoneSubnetMessage(zone.name, socket.AF_INET6,
                                                                     socket.inet_pton(socket.AF_INET6, address))
            add_zone_subnet_messages.append(add_zone_subnet_message)

        return add_zone_subnet_messages

    def _create_add_zone_subnet_messages_of_hostnames(self, zone):
        def has_zone_with_static_address(address):
            subnet = Subnet.create(address)
            zone = Zone.lookupByStaticAddressExactly(subnet)
            return zone is not None

        add_zone_subnet_messages = []
        for hostname in zone.hostnames:
            try:
                ipv4_addresses, ipv6_addresses = self.dnscache.lookupHostname(hostname)

                non_conflicting_ipv4_addresses = filter(
                    lambda ipv4_address: not has_zone_with_static_address(ipv4_address),
                    ipv4_addresses)
                non_conflicting_ipv6_addresses = filter(
                    lambda ipv6_address: not has_zone_with_static_address(ipv6_address),
                    ipv6_addresses)

                add_zone_subnet_messages += self.__create_add_zone_subnet_messages(zone, non_conflicting_ipv4_addresses,
                                                                                   non_conflicting_ipv6_addresses)
            except KeyError:
                pass
        return add_zone_subnet_messages

    def create_zone_dynamic_address_initialization_messages(self):
        messages = {}
        for zone in self.zones:
            for hostname in zone.hostnames:
                update_messages = self.create_zone_update_messages(hostname)
                updatable_zone_names = set([msg.name for msg in update_messages])
                for updatable_zone_name in updatable_zone_names:
                    zone_related_messages = filter(
                                            lambda msg: msg.name == updatable_zone_name,
                                            update_messages)
                    messages[updatable_zone_name] = zone_related_messages
        return itertools.chain(*messages.values())

    def setup(self):
        with ZoneDownload() as zone_download:
            messages = self.create_zone_static_address_initialization_messages()
            zone_download.initial(messages)
        self.setup_dns_cache()
        with ZoneDownload() as zone_download:
            messages = self.create_zone_dynamic_address_initialization_messages()
            zone_download.update(messages)

class ConfigurationHandler():
    def __init__(self):
        self.instances_conf = InstancesConf()

    def _import_zones(self):
        import os
        policy_dirs = set()

        try:
            for instance in self.instances_conf:
                policy_dirs.add(os.path.dirname(instance.zorp_process.args.policy))
        except IOError, e:
            Common.log(None, Common.CORE_INFO, 1, "Unable to open instances.conf; error='%s'" % (e))
            return

        if len(policy_dirs) > 1:
            raise ValueError('Different directories of policy files found in instances.conf; policy_dirs=%s' % policy_dirs)
        if len(policy_dirs) == 0:
            raise ValueError("No instances defined; instances_conf='%s'" % self.instances_conf.instances_conf_path)

        import imp
        policy_dir = policy_dirs.pop()
        policy_module_name = 'zones'
        try:
            fp, pathname, description = imp.find_module(policy_module_name, [policy_dir, ])
            imp.load_module(policy_module_name, fp, pathname, description)
        except ImportError, e:
            fp = None
            Common.log(None, Common.CORE_INFO, 1, "Unable to import zones.py; error='%s'" % (e))
        finally:
            if fp:
                fp.close()

    def setup(self):
        self._import_zones()

    def reload(self):
        Zone.zones = {}
        Zone.zone_subnet_tree = radix.Radix()
        self.setup()

class KeeperDaemonContext(daemon.DaemonContext):
    def open(self):
        #inherit capabilities with user change
        try:
            prctl.set_keepcaps(True)
        except OSError, e:
            Common.log(None, Common.CORE_ERROR, 1, "Unable to drop capabilities; error='%s'" % (e))
            raise e
        super(KeeperDaemonContext, self).open()

class Daemon():
    min_sleep_in_sec = 60

    def __init__(self, user, group):
        Common.log(None, Common.CORE_INFO, 1, "KZorpd starting up...")

        import grp
        import pwd
        zorp_uid = pwd.getpwnam(user).pw_uid
        zorp_gid = grp.getgrnam(group).gr_gid

        import signal
        self.context = KeeperDaemonContext(
            working_directory='/etc/zorp',
            umask=0o002,
            uid=zorp_uid,
            gid=zorp_gid,
            pidfile=PIDLockFile('/var/run/zorp/kzorpd.pid'),
            signal_map={
                         signal.SIGHUP: self.sighup_handler,
                         signal.SIGINT: self.sigint_handler,
                         signal.SIGTERM: self.sigterm_handler,
                       },
            )

        self.conf_handler = ConfigurationHandler()
        self.dnscache = ResolverCache.ResolverCache(ResolverCache.DNSResolver())
        self.zone_handler = None
        self.checkAndCreatePidfiledir()

    def sigint_handler(self, sig_num, frame):
        Common.log(None, Common.CORE_INFO, 1, "Received SIGINT, loading static zones")
        if self.zone_handler:
            with ZoneDownload() as zone_download:
                messages = self.create_zone_static_address_initialization_messages()
                zone_download.initial(messages)
        else:
            Common.log(None, Common.CORE_INFO, 1, "Failed to set up zone handler, no static zones loaded")
        exit(0)

    def sighup_handler(self, sig_num, frame):
        Common.log(None, Common.CORE_INFO, 1, "Received SIGHUP, reloading configuration")
        try:
            self.reload()
        except BaseException, e:
            Common.log(None, Common.CORE_ERROR, 1, "Unexpected error; error='%s'" % (traceback.format_exc()))

    def sigterm_handler(self, sig_num, frame):
        Common.log(None, Common.CORE_INFO, 1, "KZorpd shutting down...")
        try:
            self.context.pidfile.break_lock()
            if self.zone_handler:
                with ZoneDownload() as zone_download:
                    messages = self.create_zone_static_address_initialization_messages()
                    zone_download.initial(messages)
            else:
                Common.log(None, Common.CORE_INFO, 1, "Failed to set up zone handler, no static zones loaded")
        except BaseException, e:
            Common.log(None, Common.CORE_ERROR, 1, "Unexpected error; error='%s'" % (traceback.format_exc()))
        finally:
            exit(0)

    def checkAndCreatePidfiledir(self):
        zorpctlconf = ZorpctlConfig.Instance()
        pidfiledir = zorpctlconf['ZORP_PIDFILEDIR']
        if not os.path.exists(pidfiledir):
            owner = zorpctlconf['PIDFILE_DIR_OWNER']
            group = zorpctlconf['PIDFILE_DIR_GROUP']
            mode = zorpctlconf['PIDFILE_DIR_MODE']

            owner_uid = pwd.getpwnam(owner).pw_uid
            group_uid = pwd.getpwnam(group).pw_gid
            mode_oct = int(str(mode), 8)

            os.makedirs(pidfiledir)
            os.chown(pidfiledir, owner_uid, group_uid)
            os.chmod(pidfiledir, mode_oct)

    def setup(self):
        self.conf_handler.setup()

        from Zorp.Base import BaseZone
        self.zone_handler = DynamicZoneHandler(BaseZone.zones.values(), self.dnscache)
        self.zone_handler.setup()
        # drop capabilities
        try:
            prctl.set_caps((prctl.ALL_CAPS, prctl.CAP_EFFECTIVE, False))
        except OSError, e:
            Common.log(None, Common.CORE_ERROR, 1, "Unable to drop capabilities; error='%s'" % (e))
            raise e

    def reload(self):
        self.dnscache = ResolverCache.ResolverCache(ResolverCache.DNSResolver())
        self.conf_handler.reload()
        from Zorp.Base import BaseZone
        self.zone_handler = DynamicZoneHandler(Zone.zones.values(), self.dnscache)
        self.zone_handler.setup()

    def do_main(self):
        expired_hostname = None
        self.setup()

        while True:
            now = time.time()

            try:
                self.dnscache.update()
                try:
                    expired_hostname, expiration_time = self.dnscache.getNextExpiration()
                except ValueError, e:
                    # if no hosts are in the cache, a ValueError is raised, sleep for the minimum time
                    sleep_sec = self.min_sleep_in_sec
                    Common.log(None, Common.CORE_DEBUG, 6,
                               "No hostnames in cache, sleep minimum expiration; sleep_sec='%d'" %
                               (sleep_sec, ))
                else:
                    sleep_sec = max(expiration_time - now, self.min_sleep_in_sec)
                    Common.log(None, Common.CORE_DEBUG, 6,
                               "Sleep until next DNS expiration; sleep_sec='%d', host='%s'" %
                               (sleep_sec, expired_hostname))
            except KeyError:
                sleep_sec = self.min_sleep_in_sec
                Common.log(None, Common.CORE_DEBUG, 6,
                           "Cache lookup failed, sleep minimum expiration; sleep_sec='%d'" %
                           (sleep_sec, ))
            except BaseException, e:
                sleep_sec = self.min_sleep_in_sec
                Common.log(None, Common.CORE_ERROR, 1, "Unexpected error; error='%s'" % (traceback.format_exc()))
            finally:
                if self.zone_handler is not None:
                    if expired_hostname is not None:
                        Common.log(None, Common.CORE_INFO, 4,
                                   "TTL for host expired, updating host; hostname='%s', ttl='%d'" % (expired_hostname, expiration_time))
                        with ZoneDownload() as zone_download:
                            messages = self.zone_handler.create_zone_update_messages(expired_hostname)
                            zone_download.update(messages)
                    else:
                        with ZoneDownload() as zone_download:
                            messages = self.zone_handler.create_zone_dynamic_address_initialization_messages()
                            zone_download.update(messages)
            time.sleep(sleep_sec)

def run(foreground, log_verbosity, user, group):
    DAEMON = Daemon(user, group)

    if foreground:
        DAEMON.do_main()
    else:
        with DAEMON.context:
            DAEMON.do_main()

def process_command_line_arguments():
    import argparse

    parser = argparse.ArgumentParser(description='KZorp daemon')
    parser.add_argument("-F", "--foreground", action="store_true", dest="foreground", default=False,
                        help='do not go into the background after initialization (default: %(default)s)')
    parser.add_argument('-v', '--verbose', action='store', dest='verbose', type=int, default=3,
                        help='set verbosity level (default: %(default)d)')
    parser.add_argument('-u', '--user', action='store', dest='user', type=str, default="zorp",
                        help='set the user to run the deamon as (default: %(default)d)')
    parser.add_argument('-g', '--group', action='store', dest='group', type=str, default="zorp",
                        help='set the group to run the deamon as (default: %(default)d)')
    return parser.parse_args()

if __name__ == "__main__":
    args = process_command_line_arguments()
    run(args.foreground, args.verbose, args.user, args.group)
